package main

import (
	"fmt"
	"github.com/MakeNowJust/heredoc/v2"
	"github.com/gookit/goutil/arrutil"
	"github.com/jsumners-nr/nr-node-logviewer/internal/log"
	"github.com/spf13/cast"
	flag "github.com/spf13/pflag"
	"log/slog"
	"strings"
)

type appFlags struct {
	inputFile     string
	logLevel      *LevelFlag
	cacheFile     string
	keepCacheFile bool
}

func (a *appFlags) String() string {
	return fmt.Sprintf(
		"{ inputFile: %s, logLevel: %s, cacheFile: %s, keepCacheFile: %s }",
		a.inputFile,
		a.logLevel.String(),
		a.cacheFile,
		cast.ToString(a.keepCacheFile),
	)
}

var flags = appFlags{}

var usageText = heredoc.Doc(`
	This tool is used to process and explore agent logs generated by the Node.js
	New Relic instrumentation agent.

	The following flags are supported:
`)

func createAndParseFlags(args []string) error {
	flagSet := flag.NewFlagSet("", flag.ContinueOnError)
	flagSet.Usage = func() {
		printUsage(flagSet.FlagUsages())
	}

	flagSet.StringVarP(
		&flags.inputFile,
		"input-file",
		"f",
		"",
		"Path to a newrelic_agent.log file.",
	)

	flags.logLevel = NewLevelFlag()
	flagSet.VarP(
		flags.logLevel,
		"log-level",
		"l",
		"Set the logging level to one of: "+strings.Join(flags.logLevel.allowedValues, ", ")+".",
	)

	flagSet.StringVarP(
		&flags.cacheFile,
		"cache-file",
		"c",
		"",
		heredoc.Doc(`
			Full path and name to a file for the application to store parsed logs in.
			When not specified, a file will be created in the system's temporary
			directory. Unless --keep-cache is provided, the any cache file will be
			removed when the application ends.
		`),
	)

	flagSet.BoolVarP(
		&flags.keepCacheFile,
		"keep-cache",
		"k",
		false,
		"Keep the cache file that parsed logs are stored in.",
	)

	// TODO: add a force-parse flag that will purge any cache and force parsing of the log file

	// TODO: add a flag that will filter messages based on log type, e.g. "error" logs

	return flagSet.Parse(args[1:])
}

func printUsage(help string) {
	fmt.Println(usageText)
	fmt.Println(help)
}

type LevelFlag struct {
	value         string
	allowedValues []string
}

func NewLevelFlag() *LevelFlag {
	return &LevelFlag{
		allowedValues: []string{"info", "debug", "warn", "error", "trace"},
	}
}

func (l *LevelFlag) String() string {
	return l.value
}

func (l *LevelFlag) Set(value string) error {
	val := strings.TrimSpace(strings.ToLower(value))
	if arrutil.HasValue(l.allowedValues, val) == false {
		return fmt.Errorf("log level must be one of: %s", strings.Join(l.allowedValues, ", "))
	}
	l.value = val
	return nil
}

func (l *LevelFlag) Type() string {
	return "string"
}

func (l *LevelFlag) ToLeveler() slog.Leveler {
	var result slog.Leveler

	switch l.value {
	case "info":
		result = slog.LevelInfo
	case "debug":
		result = slog.LevelDebug
	case "warn":
		result = slog.LevelWarn
	case "error":
		result = slog.LevelError
	case "trace":
		result = log.LevelTrace
	}

	return result
}
