package main

import (
	"encoding/json"
	"fmt"
	"github.com/MakeNowJust/heredoc/v2"
	"github.com/gookit/goutil/arrutil"
	"github.com/newrelic/node-log-viewer/internal/log"
	flag "github.com/spf13/pflag"
	"log/slog"
	"strings"
)

type appFlags struct {
	InputFile          string     `json:"InputFile"`
	LogLevel           *LevelFlag `json:"LogLevel"`
	CacheFile          string
	KeepCacheFile      bool
	DumpRemotePayloads bool
	PositionalArgs     []string
}

func (a *appFlags) String() string {
	output := &strings.Builder{}
	encoder := json.NewEncoder(output)
	encoder.SetIndent("", "  ")
	err := encoder.Encode(a)
	if err != nil {
		return fmt.Sprintf("failed to marshal flags: %v", err)
	}
	return output.String()
}

var flags = appFlags{}

var usageText = heredoc.Doc(`
	This tool is used to process and explore agent logs generated by the Node.js
	New Relic instrumentation agent.

	The following flags are supported:
`)

func createAndParseFlags(args []string) error {
	flagSet := flag.NewFlagSet("", flag.ContinueOnError)
	flagSet.Usage = func() {
		printUsage(flagSet.FlagUsages())
	}

	flagSet.StringVarP(
		&flags.InputFile,
		"input-file",
		"f",
		"",
		"Path to a newrelic_agent.log file.",
	)

	flags.LogLevel = NewLevelFlag()
	flagSet.VarP(
		flags.LogLevel,
		"log-level",
		"l",
		"Set the logging level to one of: "+strings.Join(flags.LogLevel.allowedValues, ", ")+".",
	)

	flagSet.StringVarP(
		&flags.CacheFile,
		"cache-file",
		"c",
		"",
		heredoc.Doc(`
			Full path and name to a file for the application to store parsed logs in.
			When not specified, a file will be created in the system's temporary
			directory. Unless --keep-cache is provided, the any cache file will be
			removed when the application ends.
		`),
	)

	flagSet.BoolVarP(
		&flags.KeepCacheFile,
		"keep-cache",
		"k",
		false,
		"Keep the cache file that parsed logs are stored in.",
	)

	flagSet.BoolVar(
		&flags.DumpRemotePayloads,
		"dump-remote-payloads",
		false,
		heredoc.Doc(`
			Filters the provided log file down to only the logs around sending data
			to the remote collector. No UI will be shown. The logs will be written
			to stdout as NDJSON.
		`),
	)

	// TODO: add a force-parse flag that will purge any cache and force parsing of the log file

	// TODO: add a flag that will filter messages based on log type, e.g. "error" logs

	err := flagSet.Parse(args[1:])
	if err != nil {
		return err
	}

	flags.PositionalArgs = flagSet.Args()
	return nil
}

func printUsage(help string) {
	fmt.Println(usageText)
	fmt.Println(help)
}

type LevelFlag struct {
	value         string
	allowedValues []string
}

func NewLevelFlag() *LevelFlag {
	return &LevelFlag{
		allowedValues: []string{"info", "debug", "warn", "error", "trace"},
	}
}

func (l *LevelFlag) String() string {
	return l.value
}

func (l *LevelFlag) MarshalJSON() ([]byte, error) {
	return []byte(`"` + l.String() + `"`), nil
}

func (l *LevelFlag) Set(value string) error {
	val := strings.TrimSpace(strings.ToLower(value))
	if arrutil.HasValue(l.allowedValues, val) == false {
		return fmt.Errorf("log level must be one of: %s", strings.Join(l.allowedValues, ", "))
	}
	l.value = val
	return nil
}

func (l *LevelFlag) Type() string {
	return "string"
}

func (l *LevelFlag) ToLeveler() slog.Leveler {
	var result slog.Leveler

	switch l.value {
	case "info":
		result = slog.LevelInfo
	case "debug":
		result = slog.LevelDebug
	case "warn":
		result = slog.LevelWarn
	case "error":
		result = slog.LevelError
	case "trace":
		result = log.LevelTrace
	}

	return result
}
